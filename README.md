## Алгоритм решения задачи Судоку через Алгоритм X

1. Формируем массив всевозможных ограничений (cellValuesByConstraint)
для всех ячеек (пока без значений)
Например: `[("cellConstraint", (rowIndex, colIndex)), ...]`

    Ограничения:
    - cellConstraint   - в ячейке должно быть число
    - rowConstraint    - в строке с индексом rowIndex должно быть число number
    - columnConstraint - в столбце с индексом colIndex должно быть число number
    - boxConstraint    - в блоке с номером boxNumber должно быть число number

2. Формируем массив (constraintsRelatedToCellValue) типа:
    ```
   (индекс_строки, индекс_столбца, значение_ячейки) => [
        ("cellConstraint", (rowIndex, colIndex)),
        ("rowConstraint", (rowIndex, number)),
        ("columnConstraint", (colIndex, number)),
        ("boxConstraint", (boxNumber, number))
   ]
   ```

3. Формируем матрицу покрытия в cellValuesByConstraint
из этих двух массивов.

    Для каждого условия из cellValuesByConstraint
    добавляем массив значений из ключей массива constraintsRelatedToCellValue

4. Проходимся по каждой ненулевой ячейке оригинальной матрицы
и вызываем метод select, передавая в него ненулевое значение
типа `(row_index, col_index, number)`

5. Вызываем метод solve

#### Метод select:
Сокращает значения матрицы cellValuesByConstraint,
удаляя значения ячеек, которые противоречат текущим значениям матрицы

1) Перебираем каждое ограничение переданной ненулевой ячейки
2) Перебираем все значения, которые удовлетворяют
 этому конкретному ограничению и каким-то другим
3) Вычёркиваем значения ячейки из других ограничений,
 которые не совпадают с текущим рассматриваемым ограничением
 как невозможные по причине противоречия значению ненулевой ячейки
4) Запоминаем вычеркнутые ячейки в массив cols,
 чтобы потом восстановить их, если понадобится.

Значения в cols вычеркнуты из всех ограничений,
кроме текущего ограничения ненулевой ячейки

Origin grid:
```
[
    [3,2,0,4],
    [0,0,0,3],
    [2,0,0,0],
    [1,0,3,2]
]
```

**(0,0,3)**:

cols:

- **('cellConstraint', (0,0))**: `{(0,0,1), (0,0,2), (0,0,3), (0,0,4)}`
- **('rowConstraint', (0,3))**:  `{(0,2,3), (0,3,3), (0,1,3)}`
- **('columnConstraint', (0,3))**: `{(1,0,3), (2,0,3), (3,0,3)}`
- **('boxConstraint', (0,3))**: `{(1,1,3)}`

**(0,1,2)**:

cols:

- **('cellConstraint', (0, 1))**: `{(0, 1, 2), (0, 1, 1), (0, 1, 4)}`
- **('rowConstraint', (0, 2))**:  `{(0, 3, 2), (0, 2, 2)}`
- **('columnConstraint', (1, 2))**: `{(3, 1, 2), (2, 1, 2), (1, 1, 2)}`
- **('boxConstraint', (0, 2))**: `{(1, 0, 2)}`

#### Метод solve:
1. Если матрица покрытия пуста, то возвращаем результат.
Иначе - см. п.2
2. Выбираем ограничение (ключ) элемента
с наименьшим количеством значений ячеек
3. Проходимся в списке по каждому из значений ячеек,
удовлетворяющих данному ограничению
и добавляем это значение ячейки в массив решений
3. Вызываем метод select, передавая добавленное значение ячейки
4. Вызываем в цикле метод solve (самого себя),
проваливаемся вглубь рекурсии

**1-й уровень рекурсии:**

**condition:** `('cellCondition', (0,2))`

Добавлена 1 в 1-ю строку, 3-й столбец

**grid**:
```
[
    [3,2,1,4],
    [0,0,0,3],
    [2,0,0,0],
    [1,0,3,2]
]
```
**cols**: `(0,2,1), (2,2,1), (1,2,1)`

**2-й ур. рекурсии:**

**condition:** `('cellConstraint', (1, 0))`

Добавлена 4 во 2-ю строку в 1-й столбец

**grid:**
```
[
    [3,2,1,4],
    [4,0,0,3],
    [2,0,0,0],
    [1,0,3,2]
]
```
**cols:** `(1, 0, 4), (1, 1, 4)`

**3-й ур. рекурсии:**

**condition:** `('cellConstraint', (1, 0))`

Добавлена 1 во 2-ю строку во 2-й столбец

**grid:**
```
[
    [3,2,1,4],
    [4,1,0,3],
    [2,0,0,0],
    [1,0,3,2]
]
```
**cols:** `(1, 1, 1)`

**4-й ур. рекурсии:**

**condition:** `('cellConstraint', (1, 2))`

Добавлена 2 во 2-ю строку в 3-й столбец

**grid:**
```
[
    [3,2,1,4],
    [4,1,2,3],
    [2,0,0,0],
    [1,0,3,2]
]
```
**cols:** `(1, 2, 2)`

**5-й ур. рекурсии:**

**condition:** `('cellConstraint', (2, 2))`

Добавлена 4 в 3-ю строку в 3-й столбец

**grid:**
```
[
    [3,2,1,4],
    [4,1,2,3],
    [2,0,4,0],
    [1,0,3,2]
]
```
**cols:** `(2, 2, 4), (2, 1, 4)`

**6-й ур. рекурсии:**

**condition:** `('cellConstraint', (2, 1))`

Добавлена 3 в 3-ю строку во 2-й столбец

**grid:**
```
[
    [3,2,1,4],
    [4,1,2,3],
    [2,3,4,0],
    [1,0,3,2]
]
```
**cols:** `(2, 1, 3)`

**7-й ур. рекурсии:**

**condition:** `('cellConstraint', (2, 3))`

Добавлена 1 в 3-ю строку в 4-й столбец

**grid:**
```
[
    [3,2,1,4],
    [4,1,2,3],
    [2,3,4,1],
    [1,0,3,2]
]
```
**cols:** `(2, 3, 1)`

**8-й ур. рекурсии:**

**condition:** `('cellConstraint', (2, 3))`

Добавлена 1 в 3-ю строку в 4-й столбец

**grid:**
```
[
    [3,2,1,4],
    [4,1,2,3],
    [2,3,4,1],
    [1,0,3,2]
]
```
**cols:** `(2, 3, 1)`

**9-й ур. рекурсии:**

**condition:** `('cellConstraint', (3, 1))`

Добавлена 4 в 4-ю строку во 2-й столбец

**grid:**
```
[
    [3,2,1,4],
    [4,1,2,3],
    [2,3,4,1],
    [1,4,3,2]
]
```
**cols:** `(3, 1, 4)`

Дальше матрица покрытия пуста, возвращаем решение,
возвращаемся в цикл